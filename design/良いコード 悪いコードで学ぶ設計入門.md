# 良いコード/悪いコードで学ぶ設計入門 メモ

上記の本を読んで参考になったことをまとめました。<br>
良くない構造を事例に、原因や対策について解説した本になります。

## 第二章　設計の初歩
### 1. 変数を使い回さない、目的ごとの変数を用意する。<br>
→再代入することで読み手が混乱し、バグを埋め込んでしまう可能性があるため。

【修正前のコード】
```
int damageAmount = 0;
damageAmount = playerArmPower + playerWeaponPower;
damageAmount = damageAmount - ((enemyBodyDefence + enemyArmorDefence) / 2);
If (damageAmount < 0) {
    damageAmount = 0;
}
```

【修正後のコード】
```
int totalPlayerAttackPower = playerArmPower + playerWeaponPower;
int totalEnemyDefence = enemyBodyDefenfe + enemyArmorDefence;
int damageAmount = totalPlayerAttackPower - (totalEnemyDefence / 2);
If (damageAmount < 0) {
    damageAmount = 0;
}
```

### 2. 関係し合うデータとロジックをクラスにまとめる。<br>
戦闘を伴うゲームを例に、変数ではなくクラスを使用したヒットポイントの実装を説明。<br>
【ローカル変数の場合】
- ダメージを受けたり回復するロジックも併せて実装されるが、関係するロジックを探すだけでも時間が掛かる。<br>
- 変数hitpointに不正の値が入る可能性がある。

【クラスの場合】
- 関連するロジックを一箇所にまとめることができる。<br>
- 不正な値を弾くロジックを追加できる。
```
// ヒットポイントを表現するクラス<br>
class HitPoint {
    private static final int MIN = 0;
    private static final int MAX = 999;
    final int value;
    
    HitPoint(final int value) {
        if (value < MIN) throw new IllegalArgumentException(MIN + “以上を指定してください”);
        If (MAX < value) throw new IllegalArgumentException(MAX + “以下を指定してください”);

        this.value = value;<br>
    }

    // ダメージを受ける
    HitPoint damage(final int damageAmount) {
        final int damaged = value - damageAmount;
        final int corrected = damaged < MIN ? MIN : damaged;
        return new HitPoint(corrected);
    }

    // 回復する
    HitPoint recover(final int recoveryAmount) {
        final int recovered = value + recoveryAmount;
        final int corrected = MAX < recovery ? MAX : covered;
        return new HitPoint(corrected);
    }
```

## 第三章　クラス設計
### 1. メソッド引数やローカル変数にもfinalを付け不変にする<br>
→途中で値が変化すると、どう変化したのか追うのが難しくなりバグの原因にもなる。従って、基本的にメソッド引数やローカル変数は変更しない。
```
// finalで引数を不変にする
void doSomething(final int value) {
    value = 100;

// finalでローカル変数を不変にする
class Money {
    // 省略
    Money add(final int other) {
        final int added = amount + other;
        return new Money(added, currency);
```

### 2. 「値の渡し間違い」を型で防止する
→金額とチケットの枚数の型を同じint型にした場合、値渡し間違いを引き起こす可能性がある。
```
final int ticketCount = 3; // チケット枚数
money.add(ticketCount);
```

上記を防ぐために、Money型同士での加算するメソッド構造にする。int型やString型といったプリミティブ型のみを使用するのではなく、Money型のように独自の型を用いると異なる型が渡された場合にエラーで弾くことができる
```
// Money型だけ渡せるようにする
class Money {
    // 省略
    Money add(final Money other) {
        final int added = amount + other.amount;
        return new Money(added, currency);
    }
}
```


## 引用
> - 仙場 大也（2022) 「良いコード/悪いコードで学ぶ設計入門」
